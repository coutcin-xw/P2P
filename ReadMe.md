# STUN协议详解

## STUN协议介绍

### 什么是STUN	

P2P网络要求通信双方都能主动发起访问，但是NAT设备的存在，却阻断了这种主动访问，导致P2P应用无法正常运行。STUN是一种解决P2P应用NAT穿越问题的常用技术。它允许网络设备找出通信端点经NAT设备后的IP地址和端口号，并利用这些信息在通信双方之间建立一条可以穿越NAT设备的数据通道，实现P2P通信。

### STUN架构

STUN采用客户端/服务器通信模式，由STUN服务器（STUN Server）组成和STUN客户端（STUN Client）组成，其中：

- STUN服务器：是一个发送STUN绑定响应和接受STUN绑定请求的实体，例如路由器，STUN服务器通常部署在公网上。
- STUN客户端：是一个发送STUN绑定请求和接受STUN绑定响应的实体，例如路由器。

### STUN工作原理

通过STUN客户端与STUN服务器之间的报文交互，STUN服务器可以发现NAT设备的存在，并获取NAT设备分配给STUN客户端的IP地址和端口号，在STUN客户端之间建立一条数据通道。STUN客户端之间建立好数据通道之后，客户端之间可以相互访问。STUN的报文交互流程包含NAT探测和打洞两个阶段，详细的交互过程如下图所示。

![STUN报文交互过程](./STUN/download.png)
*STUN报文交互过程*

### NAT探测阶段

1. STUN客户端向STUN服务器发送STUN绑定请求报文（Binding Request）。
2. STUN服务器收到绑定请求报文后，获取请求报文中的源IP地址和源端口，并构建STUN绑定响应报文（Binding Response）发送给客户端。报文中携带MAPPED-ADDRESS、XOR-MAPPED-ADDRESS、RESPONSE-ORIGIN属性。
3. STUN客户端收到STUN绑定响应报文后，根据该报文中的MAPPED-ADDRESS或XOR-MAPPED-ADDRESS属性，获取IP地址和端口，与之前发送的STUN绑定请求报文中的源IP地址和源端口比较，如果不一致，则STUN客户端前面存在NAT设备。确定探测结果后，STUN客户端将结果返回给有需要的业务模块。

### 打洞阶段

打洞是指通过中间设备（如路由反射器）的协助在各自的NAT网关上建立相关表项，使P2P连接双方发送的报文能够直接穿透NAT网关的过程。NAT STUN的打洞流程如下：

1. STUN客户端通过BGP从路由反射器处获得其他STUN客户端的接口信息（包括NAT前后的IP地址和端口信息）。当Client1需要与Client2进行通信时，Client1会通过BGP通知Client2，它们之间需要通过打洞建立数据通道。
2. Client1与Client2互相发送STUN绑定请求进行打洞。Client1使用本端NAT前的IP地址和端口分别与Client2 NAT前和NAT后的IP地址和端口构建STUN绑定请求报文A和B发送给Client2。同时，Client2也同样进行相应的操作。
3. Client2收到报文A和B后，处理流程如下，Client1也类似：
   1. 对于报文A，若Client1与Client2在同一个私网中，也就是同一个NAT设备后侧，则报文A可以成功发送至Client2，否则报文A被丢弃。
   2. 对于Client1发出的报文B，经Client1前面的NAT设备1时会生成表项，记录Client1到Client2的会话，但是由于Client2前的NAT设备2上没有相关表项，报文B将会被丢弃。
   3. 同样的，对于Client2发出的报文B，经Client2前面的NAT设备2上将会生成表项，记录Client2到Client1的会话，但是由于Client1前的NAT设备1上没有相关表项，报文B也会被丢弃。
   4. Client1和Client2持续向对方发送绑定请求报文，当NAT设备1与NAT设备2上的会话表项都生成后，绑定请求报文就可以成功发送至对端Client。
4. Client2收到STUN绑定请求报文后，向Client1发送STUN绑定响应报文，Client1也同样进行相应的操作。



## STUN协议报文详解（RFC5389）

### STUN消息结构

```txt
+---------------+---------------+---------------+---------------+
|0              |1              |2              |3              |
+---------------+---------------+---------------+---------------+
|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Message Type           |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Magic Cookie                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                      Transaction ID (96 bits)                 |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Attributes                        |
|                             ...                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**字段详解：**

- **Message Type（2字节）**：标识消息类别

  ```t x t
  +-----------------------+-----------------------+
  |           0           |           1           |
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |0 |1 |2 |3 |4 |5 |6 |7 |0 |1 |2 |3 |4 |5 |6 |7 |
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |- |- |M |M |M |M |M |C |M |M |M |C |M |M |M |M |
  |  |  |11|10|9 |8 |7 |1 |6 |5 |4 |0 |3 |2 |1 |0 |
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |0 |0 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  ```

  - 最高的2位必须置零，这可以在当STUN和其他协议复用的时候，用来区分STUN包和其他数据包。

  - M11到M0表示方法的12位编码（MessageMethod）。C1和C0两位表示类的编码。（MessageClass）

  - 因此：MessageType=MessageClass | MessageMethod

    例如对于binding方法来说，

    MessageClass定义：0b00表示request，0b01表示indication，0b10表示success response，0b11表示error response

    Message Method定义为0x001，

    ![img](./STUN/d84cd38799405bf1c3f964a4f639b833.png)

  - 根据 **STUN协议RFC5389标准**，消息的 **Method（方法）** 用于定义消息的核心用途。RFC5389 中仅规范了 **Binding方法**（用于NAT穿透场景的地址映射），其他方法（如TURN扩展的`Allocate`或`Send`）属于其他RFC文档定义。

    以下是 **RFC5389核心定义的Message Method及消息类型**：

    ------

    ### **STUN Message Method (RFC5389)**

    | Method名称  | Method值 (Hex) | 消息类型（Class） | 消息类型值 (Hex) | 描述                                                         |
    | ----------- | -------------- | ----------------- | ---------------- | ------------------------------------------------------------ |
    | **Binding** | `0x001`        | **Request**       | `0x0001`         | 客户端请求服务器返回其公网地址映射（NAT穿透的核心操作）      |
    |             |                | **Success**       | `0x0101`         | 服务器成功响应客户端的Binding请求，返回XOR-MAPPED-ADDRESS等属性 |
    |             |                | **Failure**       | `0x0111`         | 服务器返回错误码（如认证失败、格式错误等）                   |
    |             |                | **Indication**    | `0x0011`         | 单向通知消息（无响应），用于保活或状态更新（RFC5389中未详细定义用途） |

- **Message Length（2字节）**：消息总长度（不包括头部）字段存储了信息的长度，以字节为单位，不包括20字节的STUN头部。由于所有的STUN属性都是都是4字节对齐（填充）的，因此这个字段最后两位应该恒等于零，这也是辨别STUN包的一个方法之一。

- **Magic Cookie（4字节）**：固定值0x2112A442，这是为了前向兼容RFC3489，因为在classic STUN中，这一区域是事务ID的一部分。另外选择固定数值也是为了服务器判断客户端是否能识别特定的属性。还有一个作用就是在协议多路复用时候也可以将其作为判断标志之一

- **Transaction ID（96位）**：Transaction ID 字段是个96位的标识符，用来区分不同的STUN传输事务。对于request/response传输，事务ID由客户端选择，服务器收到后以同样的事务ID返回response；对于indication则由发送方自行选择。事务ID的主要功能是把request和response联系起来，同时也在防止攻击方面有一定作用。服务端也把事务ID当作一个Key来识别不同的STUN客户端，因此必须格式化且随机在0~2^(96-1)之间。重发同样的request请求时可以重用相同的事务ID，但是客户端进行新的传输时，必须选择一个新的事务ID。

- **Attributes**  

  - 在STUN报文头部之后，通常跟着0个或者多个属性，每个属性必须是TLV编码的（Type-Length-Value）。其中Type字段和Length字段都是16位，Value字段为为32位表示，如下：

```txt
+---------------+---------------+---------------+---------------+
|0              |1              |2              |3              |
+---------------+---------------+---------------+---------------+
|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Type              |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Value                             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

attributes的Type(**RFC5389**)定义如下：

| Type值 (Hex) | 属性名称           | RFC版本 | 状态                  | 描述                                                |
| ------------ | ------------------ | ------- | --------------------- | --------------------------------------------------- |
| **0x0001**   | MAPPED-ADDRESS     | RFC3489 | 已废弃（RFC5389保留） | 客户端公网地址，因未加密被弃用                      |
| **0x0006**   | USERNAME           | RFC5389 | 必须支持              | 认证用户名                                          |
| **0x0008**   | MESSAGE-INTEGRITY  | RFC5389 | 必须支持              | HMAC-SHA1消息完整性校验                             |
| **0x0009**   | ERROR-CODE         | RFC5389 | 必须支持              | 错误代码及原因描述（格式：3位码+文本）              |
| **0x000A**   | UNKNOWN-ATTRIBUTES | RFC5389 | 必须支持              | 标记客户端不支持的属性列表                          |
| **0x0014**   | REALM              | RFC5389 | 必须支持              | 服务器认证域（类似HTTP Basic Auth的Realm）          |
| **0x0015**   | NONCE              | RFC5389 | 必须支持              | 服务器生成的随机数，用于认证防重放                  |
| **0x0020**   | XOR-MAPPED-ADDRESS | RFC5389 | 必须支持              | 异或加密的公网地址（取代MAPPED-ADDRESS）            |
| **0x0022**   | SOFTWARE           | RFC5389 | 可选支持              | 客户端/服务端软件标识（如"ExampleStunServer v1.0"） |
| **0x8028**   | FINGERPRINT        | RFC5389 | 可选支持              | 消息尾部的CRC32校验码（用于兼容性检测）             |

## NAT类型检查用到的报文

